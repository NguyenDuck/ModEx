/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A version that tells minecraft what type of data format can be expected when reading this file.
 */
export type FormatVersion = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier = string;
/**
 * Named reference to the feature controlled by this rule.
 */
export type PlacesFeature = string;
/**
 * When the feature should be placed relative to others. Earlier passes in the list are guaranteed to occur before later passes. Order is not guaranteed within each pass.
 */
export type PlacementPass =
  | "pregeneration_pass"
  | "first_pass"
  | "before_underground_pass"
  | "underground_pass"
  | "after_underground_pass"
  | "before_surface_pass"
  | "surface_pass"
  | "after_surface_pass"
  | "before_sky_pass"
  | "sky_pass"
  | "after_sky_pass"
  | "final_pass";
/**
 * List of filter tests to determine which biomes this rule will attach to.
 */
export type BiomeFilter = EGroupsSpec[] | EFiltersSpec;
export type EGroupsSpec = EGroupsSpec[] | EFiltersSpec;
export type EFiltersSpec =
  | {
      all_of?: AllOf;
      any_of?: AnyOf;
      none_of?: NoneOf;
      [k: string]: unknown;
    }
  | ({
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    } & {
      [k: string]: unknown;
    });
/**
 * All tests in an `all_of` group must pass in order for the group to pass.
 */
export type AllOf = EGroupsSpec[] | EFiltersSpec;
/**
 * One or more tests in an `any_of` group must pass in order for the group to pass.
 */
export type AnyOf = EGroupsSpec[] | EFiltersSpec;
/**
 * All tests in a `none_of` group must fail in order for the group to pass.
 */
export type NoneOf = EGroupsSpec[] | EFiltersSpec;
/**
 * The order in which coordinates will be evaluated. Should be used when a coordinate depends on another. If omitted, defaults to `xzy`.
 */
export type CoordinateEvalOrder = "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx";
/**
 * Number of scattered positions to generate.
 */
export type Iterations = string | number;
export type ScatterChance =
  | MolangNumber
  | {
      numerator?: Numerator;
      denominator?: Denominator;
    };
/**
 * Probability (0-100] that this scatter will occur.  Not evaluated each iteration; either no iterations will run, or all will.
 */
export type MolangNumber = string | number;
/**
 * UNDOCUMENTED.
 */
export type Numerator = number;
/**
 * UNDOCUMENTED.
 */
export type Denominator = number;
/**
 * UNDOCUMENTED.
 */
export type X =
  | MolangNumber1
  | {
      numerator?: Numerator1;
      denominator?: Denominator1;
    }
  | {
      distribution?: Distribution1;
      extent?: Extent;
    };
/**
 * Expression for the coordinate (evaluated each iteration).  Mutually exclusive with random distribution object below.
 */
export type MolangNumber1 = string | number;
/**
 * UNDOCUMENTED.
 */
export type Numerator1 = number;
/**
 * UNDOCUMENTED.
 */
export type Denominator1 = number;
/**
 * Distribution type
 */
export type Distribution1 = "uniform" | "fixed_grid" | "jittered_grid" | "gaussian" | "inverse_gaussian" | "triangle";
/**
 * Represents the range of values on which that distribution operates, from minimum to maximum.
 *
 * @minItems 2
 * @maxItems 2
 */
export type Extent = [number, number];
/**
 * UNDOCUMENTED.
 */
export type Y =
  | MolangNumber1
  | {
      numerator?: Numerator1;
      denominator?: Denominator1;
    }
  | {
      distribution?: Distribution1;
      extent?: Extent;
    };
/**
 * UNDOCUMENTED.
 */
export type Z =
  | MolangNumber1
  | {
      numerator?: Numerator1;
      denominator?: Denominator1;
    }
  | {
      distribution?: Distribution1;
      extent?: Extent;
    };

/**
 * Each feature rule controls exactly one feature and serves as the root of a chain of feature data.
 */
export interface FeatureRules {
  format_version: FormatVersion;
  "minecraft:feature_rules": FeatureRules1;
}
export interface FeatureRules1 {
  description?: Description;
  conditions?: Conditions;
  distribution?: Distribution;
}
/**
 * The description of this feature rule.
 */
export interface Description {
  identifier: Identifier;
  places_feature: PlacesFeature;
}
/**
 * Parameters to control where and when the feature will be placed.
 */
export interface Conditions {
  placement_pass: PlacementPass;
  "minecraft:biome_filter"?: BiomeFilter;
}
/**
 * Parameters controlling the initial scatter of the feature.
 */
export interface Distribution {
  coordinate_eval_order?: CoordinateEvalOrder;
  iterations: Iterations;
  scatter_chance?: ScatterChance;
  x?: X;
  z?: Y;
  y?: Z;
}
